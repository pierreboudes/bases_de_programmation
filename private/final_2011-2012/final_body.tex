% -*- coding: utf-8 -*-


\newcounter{questioncount}
\setcounter{questioncount}{0}
\newcommand{\question}{\addtocounter{questioncount}{1}\paragraph{Question \Alph{questioncount}.}}
\newcommand{\commentaire}[1]{}
\newcommand{\pt}[1]{\fbox{$#1 \operatorname{pt}$}}

\entete{Éléments d'informatique : partiel de fin de semestre}
\vspace{-1cm}
\begin{description}
\item[Durée :] 3 heures.
\item[Documents autorisés :] Aucun.
\item[Recommandations :] Un barème vous est donné à
titre indicatif, afin de vous permettre de gérer votre temps. Ne
dépassez pas les temps indiqués.
\end{description}

\section{Étude de programmes et questions de cours}

\subsection{Somme des éléments d'un tableau (\emph{2,5 points})}

Nous voulons écrire un programme qui calcule la somme des éléments
d'un tableau d'entiers. Une partie du programme est déjà écrite, et
Pippo pense qu'il ne
reste plus qu'à écrire la partie qui calcule effectivement la
somme. Voici son programme :
\begin{listing}{1}
#include <stdlib.h> /* EXIT_SUCCESS */
#include <stdio.h> /* printf, scanf */

/* déclaration constantes et types utilisateurs */
#define TAILLE 3

/* Fonction principale */
int main()
{
  int t[TAILLE] = {12,10,15}; /* tableau à sommer */



  /* calcul de la somme (À FAIRE) */





  /* affichage du résultat */
  printf("La somme est %d\n", somme);

  /* valeur fonction */
  return EXIT_SUCCESS;
}
\end{listing}

\question Avant d'aller plus loin Pippo veut tester son programme,
mais la compilation échoue. Expliquer pourquoi, quelle étape de la
compilation échoue précisément et ce qu'il manque pour que la
compilation réussisse.  \bareme{1}

\begin{correction}
Il manque la déclaration (et l'initialisation à zéro) de la variable
\C{somme}. La compilation échoue à l'analyse sémantique. 
\begin{baremeenv}
  \begin{description}
  \item[0.5 pt] pour << déclaration de la variable \C{somme} >>
  \item[0.5 pt] pour << analyse sémantique >> ou 0.25 pt si << avant
    la génération du code objet >> et/ou << avant l'édition de lien
    >>.
  \end{description}
\end{baremeenv}
\end{correction}

\question Compléter le programme pour qu'il calcule effectivement la somme
  des éléments du tableau (pour une taille de tableau arbitraire).\bareme{1.5}

Un exemple de sortie du programme pour le tableau donné dans le code est :
\begin{verbatim}
La somme est 37
\end{verbatim}

\begin{correction}

  \begin{listing}{11}
  int somme = 0; /* accumulateur pour la somme */    
  int i; /* var de boucle */

  for (i = 0; i < TAILLE; i = i + 1) /* pour chaque case */
  {
    somme = somme + t[i]; /* ajout de la case a la somme */   
  }
  \end{listing}

  \begin{baremeenv}
    \pt{1.5} pour le code juste (compilation correction quel que soit
    TAILLE). Pas de points en moins ou en plus pour la déclaration de
    la variable de boucle (redite sous une autre forme de la première
    question) ou pour l'initialisation de somme à zéro. Sinon, maximum
    \pt{1} :
  \begin{description}
  \item[zéro]  si pas de boucle mettre zéro à la question
  \item[0.5 pt]  une (et une seule) boucle (for, while accepté)
  \item[+0.5 pt]  la boucle parcours effectivement un tableau de taille TAILLE
 \end{description}
  \end{baremeenv}
\end{correction}

\subsection{Une erreur classique (\emph{1 points})} 

Pippo a écrit un programme C. Celui-ci compile, mais une erreur
survient à l'exécution, qu'il ne comprend pas.

\begin{verbatim}
$ gcc puissance.c -o puissance.exe
$ puissance.exe
Entrer un nombre reel : 2.3
Entrer son exposant (entier positif) : 2
Segmentation fault
\end{verbatim}
\question
Expliquer brièvement ce que signifie ce message d'erreur (dernière ligne).\bareme{1}
\begin{correction}
Le message d'erreur \C{Segmentation fault} signifie que le programme a tenté de lire ou d'écrire dans un espace mémoire qui ne lui était pas réservé, ce que le système a détecté et refusé, provoquant la terminaison prématurée du programme et l'affichage du message d'erreur. 

\begin{baremeenv}
Maximum \pt{1}.
 \begin{description}
    \item[1 pt] il faut que la réponse parle de mémoire et soit de
      (non) réservation/allocation au processus/programme, soit
      d'intervention du système d'exploitation.
    \item[0.5 pt] s'il est juste fait mention de la mémoire (sans
      réservation etc.).
    \item[+0.25 pt] si ça parle d'une erreur dans l'écriture d'un scanf.
  \end{description}
\end{baremeenv}
\end{correction}

% \question
% Voici quelques lignes choisies du programme.
% \begin{listing}{10}
% int main()
% {
%    double x;
%    int n;
% \end{listing}
% \vdots
% \begin{listing}{22}
%     printf("Entrer un nombre reel : ");
%     scanf("%lg", x);
%     printf("Entrer son exposant (entier positif) : ");
%     scanf("%d", n);
% \end{listing}
% Que faut-il corriger ? \bareme{1}

% \begin{correction}
% Il faut mettre une esperluette devant le nom de la variable dans les deux \C{scanf}.
%  Comme ceci :
%   \begin{listing}{23}
%     printf("Entrer un nombre reel : ");
%     scanf("%lg", &x); /* <-- ici */
%     printf("Entrer son exposant (entier positif) : ");
%     scanf("%d", &n);  /* <-- ici */
% \end{listing}

% Complément de correction.
% Le rôle de l'esperluette est de donner à \C{scanf} l'adresse de la variable dans laquelle écrire le résultat de la saisie utilisateur. Sans esperluette \C{scanf} récupère la valeur de la variable et l'utilise comme une adresse, ce qui provoque en général (si on a de la chance) une erreur de segmentation (\C{Segmentation fault}). 

% \begin{baremeenv}
%   Compter 0.5 pt par scanf correctement corrigé (et oui c'est un piège). Si d'autres corrections, hors sujet, apparaissent diminuer la note de l'exercice (jusqu'à zéro).
% \end{baremeenv}
% \end{correction}



\section{Trace d'un programme avec fonctions (\emph{4 points})}

\question Simulez l'exécution du programme figure~\ref{fig:prog} page~\pageref{fig:prog}, en réalisant sa
\textbf{trace}, comme cela a été vu en TD et en cours. \bareme{4}

\begin{figure}[htb]
  \centering
\begin{small}
\begin{listing}{1}
#include <stdlib.h> /* EXIT_SUCCESS */
#include <stdio.h> /* printf, scanf */

/* declarations constantes et types utilisateurs */

/* declarations de fonctions utilisateurs */
int foo(int a, int b);
int bar(int n);

int main()
{
    int x = 2;
    int y = 6;
    int res;
    res = foo(x, y);
    printf("foo(%d, %d) = %d\n", x, y, res);
    res = bar(x);
    printf("bar(%d) = %d\n", x, res);
    
    return EXIT_SUCCESS;
}

/* definitions de fonctions utilisateurs */
int foo(int a, int b)
{
    if (a < b)
    {
        return a;
    }
    return b;
}

int bar(int n)
{
   if (n > 1) 
   {
       return n * bar(n - 1);
   }
   return 1;
}
\end{listing}
\end{small} 
  \caption{Programme pour la trace}
  \label{fig:prog}
\end{figure}

\begin{correction}
  Table~\ref{trace} page~\pageref{trace}. 

  \begin{table}
  \begin{small} 
   \setlength{\unitlength}{\tabcolsep}
    \begin{tabular}[t]{|r|c|c|c|l|}
      \multicolumn{5}{l}{\C{main()}}\\ \hline
      ligne & x & y & res & Affichage\\ \hline
      ini.  & 2 & 6 & ? & \\ \hline
      15 &\multicolumn{4}{r|}{
        \put(1,0){\noindent
          \begin{tabular}[t]{|r|c|c|}
            \multicolumn{3}{l}{\C{foo(2, 6)}}\\ \hline
            ligne & a & b \\ \hline
            ini. & 2 & 6 \\ \hline
           28 & \multicolumn{2}{l|}{renvoie 2} \\ \hline
          \end{tabular}
        }}\\ \hline
      15 & & & 2 & \\ \hline
      16 & & &  &   foo(2, 6) = 2\carriagereturn \\ \hline
      17 &\multicolumn{4}{r|}{
        \put(1,0){\noindent
          \begin{tabular}[t]{|r|c|}
            \multicolumn{2}{l}{\C{bar(2)}}\\ \hline
            ligne & n  \\ \hline
            ini. & 2 \\ \hline
            37 &\multicolumn{1}{r|}{
              \put(1,0){\noindent
                \begin{tabular}[t]{|r|c|}
                  \multicolumn{2}{l}{\C{bar(1)}}\\ \hline
                  ligne & n  \\ \hline
                  ini. & 1 \\ \hline
                  39 & \multicolumn{1}{l|}{renvoie 1} \\ \hline
                \end{tabular}
              }}\\ \hline
            37 & \multicolumn{1}{l|}{renvoie 2} \\ \hline
          \end{tabular}
        }}\\ \hline
      17 & & & 2 & \\ \hline
      18 & & &  & bar(2) = 2\carriagereturn \\ \hline
      20 & \multicolumn{4}{l|}{renvoie \C{EXIT\_SUCCESS}} \\ \hline
     \end{tabular}
        \caption{Trace du programme de l'exercice 2.}
        \label{trace}
\end{small}
  \end{table}
\end{correction}

\begin{baremeenv}
%\newpage
 Maximum \pt{4}. Si des erreurs, maximum \pt{3,75}.
  \begin{enumerate}[(a)]
\item \pt{+1} deux premières lignes de la trace du main sont correctes
  (identification des variables et leurs initialisations).
  \begin{enumerate}[$\ast$]
  \item \pt{-0,5} par variable manquante ou en trop
  \item \pt{-0,5} par initialisation manquante ou en trop.
  \end{enumerate}
\item \pt{+1,25} \textbf{Pour l'appel à foo :}
  \begin{enumerate}[$\ast$]
  \item \pt{+0,25} pour \C{foo(2, 6)} ligne 15
  \item \pt{+0,25} pour les deux colonnes pour les paramètres formels a
    et b
  \item \pt{+0,25} pour l'initialisation correcte des paramètres formels a
    et b
\item \pt{+0,25} pour le retour d'un entier (même si valeur fausse)
\item \pt{+0,25} ligne 15 affectation en accord avec la valeur retournée.
 \end{enumerate}
\item \pt{+1,25}  \textbf{Pour l'appel récursif à bar :}
  \begin{enumerate}[$\ast$]
  \item \pt{+0,25} pour \C{bar(2)} ligne 17
  \item \pt{+0,5} pour le déclenchement du second appel ligne 37,
    compter uniquement \pt{+0,25} si il y a plus de deux appels
  \item \pt{+0,25} une colonne pour le paramètre formel n bien
    initialisé à 2 ou à 1 dans le second appel (l'un des deux suffit)
  \item \pt{+0,25} pour le retour de la valeur et l'affectaction en
    accord avec la valeur retournée ligne 17
\end{enumerate}
\item \pt{+0,25} pour au moins l'un des deux affichages (ligne 16 et
  ligne 18) avec des valeurs cohérentes avec le contenu des colonnes
  du main.
\end{enumerate}
\end{baremeenv}

\section{For ou while ? (\emph{4,5 points})}

Il est demandé de résoudre les questions suivantes sans définir de
fonctions utilisateurs, directement dans le \C{main}, et en faisant le meilleur choix entre \C{for}
et \C{while}.

\question Écrire un programme qui étant donné deux variables entières
\C{largeur} et \C{hauteur}, initialisées à des valeurs de votre choix,
affiche un rectangle d'étoiles de dimension \C{largeur} par
\C{hauteur}. Dans l'exemple d'affichage suivant \C{largeur} vaut 6 et \C{hauteur}
vaut 4.\bareme{1,5}
\begin{verbatim}
******
******
******
******
\end{verbatim}

\begin{correction}
  \begin{listing}{1}
/* Declaration de fonctionnalites supplementaires */
#include <stdlib.h> /* pour EXIT_SUCCESS */
#include <stdio.h> /* pour printf() et scanf() */

/* Fonction principale */
int main()
{
    int largeur = 6;
    int hauteur = 4;
    int i; /* var de boucle */
    int j; /* var de boucle */
    for (i = 0; i < hauteur; i = i + 1) /* pour chaque ligne */
    {
	/* afficher une ligne de largeur etoiles */
	for (j = 0; j < largeur; j = j + 1) /* repeter largeur fois */
	{
	    printf("*");
	}
	printf("\n"); /* fin de la ligne */
    }	

    return EXIT_SUCCESS;
}
  \end{listing}
  \begin{baremeenv}
   \begin{description}
      \item[zéro] Si pas de boucle
\item[1,5 pt] Si le programme fonctionne correctement, avec deux
  variables (pas des constantes symboliques), largeur et hauteur, pour
  n'importes quelles valeurs positives de ces variables, même s'il y a
  des trucs inutiles autour (saisie par l'utilisateur, constantes
  symboliques, etc.).
\item[0,5 pt] Si le programme contient deux boucles imbriquées 
  \begin{description}
  \item[+0,25 pt] si ce sont des for.
  \end{description}
\item[+0,25 pt] si l'une des boucles du programme est répétée largeur ou hauteur
  fois avec une variable de boucle (ou un compteur si c'est un while)
  correctement déclaré,
\item[+0,25 pt] si largeur et hauteur sont déclarées et initialisées
  comme variables entières.
  \end{description}
  \end{baremeenv}
\end{correction}

\question Expliquer comment modifier le programme précédent pour qu'il
affiche le contour du rectangle avec des étoiles et l'intérieur avec
des espaces.\bareme{1}
\begin{verbatim}
******
*    *
*    *
******
\end{verbatim}

\begin{correction}
On remplace la ligne 17 du programme précédent par les lignes suivantes.
  \begin{listing}{17}
	    if ( (0 == i) 
		 || (0 == j)
		 || (hauteur - 1 == i)
		 || (largeur - 1 == j))
	    {
		printf("*");
	    }
	    else
	    {
		printf(" ");
	    }    
  \end{listing}
Ainsi si \C{i} ou \C{j} sont sur un bord du rectangle c'est une étoile
qui sera affichée, un espace blanc autrement.
\begin{baremeenv}
  Il y a deux types de solutions : soit faire plus de boucles
  successives (cas particuliers), soit placer une ou plusieurs
  conditionnel dans le code interne à la (double) boucle. Toutes les
  deux sont admises et valent au maximum un point.

  Pour la première solution compter \pt{0,25} par bord correctement
  dessiné : (première ligne et dernière ligne comme boucles à part,
  lignes du milieu : étoile initial à part, ligne de blancs, étoile
  finale à part). 

  Pour la seconde solution, compter \pt{0,5} si la solution repose sur
  un ou plusieurs if else (enlever \pt{0,25} si seul le cas if est
  traité, sans tenir compte des espaces blancs) et compter \pt{+0,25
    pt} si il y a seulement une des erreurs suivantes : utilisation
  d'un et logique au lieu du ou, ou bien deux bords faux au maximum.
\end{baremeenv}
\end{correction}

\question Écrire un programme qui, étant donné un tableau d'entier
initialisé à des valeurs de votre choix, demande à l'utilisateur de
saisir un entier puis si l'entier saisi est dans le tableau affiche son indice
et sinon affiche à l'utilisateur \C{entier absent du tableau}. 
\bareme{2}
\begin{correction}
  \begin{listing}{1}
/* Declaration de fonctionnalites supplementaires */
#include <stdlib.h> /* pour EXIT_SUCCESS */
#include <stdio.h> /* pour printf() et scanf() */

/* Declarations de constantes */
#define TAILLE 5
#define TRUE 1
#define FALSE 0
/* Fonction principale */
int main()
{
    int tab[TAILLE] = {1, 2, 4, 2, 5};
    int x; /* valeur cherchée */
    int trouve = FALSE;
    int i = 0; /* var de boucle */
 
    /* saisie utilisateur */
    printf("entier recherché ? ");
    scanf("%d", &x);

    /* recherche dans le tableau */
    while ((!trouve) && (i < TAILLE)) 
    /* tant qu'on n'a pas trouvé et qu'il reste des éléments à
     * parcourir */
    {
	if (x == tab[i])
	{
	    trouve = TRUE;
	}
	else
	{
	    i = i + 1;
	}
    } 

    /* affichage du résultat */
    if (trouve)
    {
	printf("entier %d trouvé à l'indice %d\n", x, i);
    }
    else
    {
	printf("entier absent du tableau\n");
    }

    return EXIT_SUCCESS;
}
\end{listing}
\begin{baremeenv}
  On propose un corrigé avec séparation du traitement et de
  l'affichage et une variable booléenne pour réguler la poursuite de
  la recherche, qui du coup nécessite des variables booléennes. Une
  solution plus compacte est admise si elle fonctionne. Dans ce cas,
  si elle repose effectivement sur un parcours partiel du tableau
  (normalement à base
  de while), on compte \pt{2}, si le
  programme parcourt tout le tableau (solution de type for) on compte \pt{1,5}.

 Si la solution ne fonctionne pas, on travaille avec le barème
 suivant, en \textbf{limitant le total} des points à \pt{1,75}.

 \begin{description}

\item[Déclaration du tableau] \pt{0,5} offerts (il suffit de
  s'inspirer de l'énoncé du premier exercice)
   \begin{description}
   \item[0,25 pt] déclaration et initialisation correcte du tableau
   \item[+0,25 pt] si utilise une constante symbolique prélablement
     déclarée pour la taille du tableau
   \end{description}
 \item[Saisie] \pt{0,5}
  \begin{description}
  \item[0,25 pt] pour une (tentative de) saisie : printf suivi de scanf
    avec référence à une variable de type entier dans le scanf,
    préalablement déclarée
  \item[0,25 pt] si le scanf a la bonne syntaxe (\%d et \&).
  \end{description}
\item[Boucle] \pt{0,75}
  \begin{description}
  \item[0,5] il y a exactement une boucle.
  \item[+0,5] c'est un while.
  \item[+0,25] la condition de boucle teste le débordement de tableau
    (condition du for ou du while).
  \end{description}
\item[Extras] 
  \begin{description}
  \item[+0,25 pt] le programme utilise une variable booléenne, et les
    constantes symboliques TRUE et FALSE.
  \item[+ 0,25] Pour la présence des deux cas d'affichage (si trouvé
    si pas trouvé) avec affichage de l'indice et non de la valeur
    cherchée.
  \end{description}
 \end{description}
\end{baremeenv}
\end{correction}

\section{Fractions (\emph{5 points})}

\question Une fraction $\frac{p}{q}$ est définie par deux entiers $p$ et $q$. Le nombre
$q$ appelé dénominateur est nécessairement non nul et sera toujours positif, le
nombre $p$, appelé numérateur, peut être négatif ou nul. Définir un
type utilisateur pour les fractions (sans tenir compte des questions
de signe qui n'ont d'importance que pour l'affichage).
\bareme{1}
\begin{correction}
\begin{verbatim}
struct fraction_s
{
  int num; /* nunérateur */
  int den; /* dénominateur */
}; /* <- n'oublie pas le point-virgule ! */
\end{verbatim}
 \begin{baremeenv}
  Soit tout juste (noms arbitraires) soit faux.
    \begin{description}
    \item[1 pt] même si oublie du point-virgule final, ou si typedef
    \item[zéro] sinon
   \end{description}
  \end{baremeenv}
\end{correction}

\question Déclarer et définir une fonction \C{multiplier\_fractions} qui
    prend deux fractions en argument et renvoie la fraction obtenue par multiplication des deux
    fractions (ne pas chercher à simplifier la fraction
    obtenue). \emph{Répondre en faisant bien apparaître d'une part la
      déclaration, d'autre part la définition.}
\bareme{1.5}
\begin{correction}
Déclaration :
\begin{verbatim}
struct fraction_s multiplier_fractions(struct fraction_s x, 
                                       struct fraction_s y);
\end{verbatim}
Définition :
\begin{verbatim}
struct fraction_s multiplier_fractions(struct fraction_s x, 
                                       struct fraction_s y)
{
  struct fraction_s res;
  res.num = x.num * y.num; /* produit des numérateurs "sur" */
  res.den = x.den * y.den; /* produit des dénominateurs */
  return res;
}
\end{verbatim}

  \begin{baremeenv}
    Maximum \pt{1,5}. Sinon :
    \begin{description}
    \item[0,5] pour la déclaration exacte.
    \item[1] pour la définition.
    \item[0,5] si la définition retourne effectivement un point mais
      qui n'a pas la bonne valeur.
    \end{description}
  \end{baremeenv}
\end{correction}

\question Même question pour la somme de deux fractions
    \C{additionner\_fractions}.
\bareme{1}

\begin{correction}
Déclaration :
\begin{verbatim}
struct fraction_s additionner_fractions(struct fraction_s x, 
                                        struct fraction_s y);
\end{verbatim}
Définition :
\begin{verbatim}
struct fraction_s additionner_fractions(struct fraction_s x, 
                                        struct fraction_s y)
{
  struct fraction_s res;
  res.num = x.num * y.den + y.num * x.den;
  res.den = x.den * y.den; /* produit des dénominateurs */
  return res;
}
\end{verbatim}

\begin{baremeenv}
Maximum \pt{1}.
  \begin{description}
  \item[0,25] pour la déclaration exacte.
  \item[0,75] pour la définition, dont \pt[0,5] pour un dénominateur exact.
\end{description}
\end{baremeenv}  
\end{correction}


\question Déclarer et définir une procédure affichant une fraction
passée en argument exactement comme dans l'exemple suivant où les
fractions $\frac{34}{26}$, $\frac{-34}{26}$, $\frac{34}{1}$,
$\frac{0}{1}$ sont affichées tour à tour :
\begin{verbatim}
34/26
-34/26
34 
0
\end{verbatim}
Attention à bien respecter les deux derniers affichages.
\bareme{1.5}

\begin{correction}
Déclaration :
\begin{verbatim}
void afficher_fraction(struct fraction_s x);
\end{verbatim}
Définition :
\begin{verbatim}
void afficher_fraction(struct fraction_s x);
{
  if (x.den == 1)
  {
    printf("%d\n", x.num);
  }
  else
  {
    printf("%d/%d\n", x.num, x.den);
  }
}
\end{verbatim}
\begin{baremeenv}
Maximum \pt{1,5}.
  \begin{description}
  \item[0,5] pou la déclaration exacte.
  \item[1] pour la définition, dont \pt{0,5} pour la simple présence d'un if.
 \end{description}
\end{baremeenv}  
\end{correction}

\section{Fonctions \emph{(3 points)}}
\question Déclarer et définir :
\begin{enumerate}
\item une fonction \verb|valeur_absolue| qui  prend en entrée un argument réel
  et retourne sa valeur absolue;\bareme{1}
\item Une procédure \verb|afficher_ligne| qui prend en entrée un
  entier \C{n} et un caractère \C{c} et affiche une ligne contenant
  \C{n} fois la caractère \C{c};\bareme{1}
\item Une fonction \verb|neper| qui prend en entrée un entier \C{n} et
  retourne la valeur de la somme suivante :
\[
1 + \sum^{k = n}_{k = 1} \frac{1}{k!}.
\]
Vous pouvez faire appel à une
  fonction \verb|int factorielle(int n)| calculant la factorielle de
  son argument.\bareme{1}
\end{enumerate}


\begin{correction}
Déclarations :
\begin{verbatim}
double valeur_absolue(double x);
void afficher_ligne(int n, char c);
double neper(int n);
\end{verbatim}

Définitions :
\begin{verbatim}
double valeur_absolue(double x)
{
  if (x < 0)
  {
    return -x;
  }
  return x;
}

void afficher_ligne(int n, char c)
{
  int i;
  for (i = 0; i < n; i = i + 1)
  {
    printf("%c", c);
  }
  printf("\n"); /* optionnel */
}

double neper(int n) /* récursive */
{
  if (n > 1)
  {
    return neper(n - 1) + 1.0/factorielle(n);
  }
  return 1.0;
}
/* alternative plus classique */
double neper(int n) 
{
  double somme = 1.0;
  int i;
  for (i = 1; i <= n; i = i + 1)
  {
    somme = somme + 1.0/factorielle(i);
  }
  return somme;
}

\end{verbatim}

  \begin{baremeenv}
    On note \pt{0,5} par déclaration exacte et \pt{0,5} par définition
    correcte (en dehors de la question de typage) en admettant comme
    erreurs l'oublie de l'utilisation de \C{\%c} pour l'affichage d'un
    caractère, une erreur d'indice à un près dans les boucles, un
    problème d'arrondi entier.

   On ajoute \pt{0,5} si il est fait correctement appel à  la fonction factorielle,
   tant que la syntaxe d'appel est correct et quelle que soit les
   paramètres et l'usage de cet appel.
  \end{baremeenv}
\end{correction}

\section*{Bonus}
\paragraph{Question bonus.} Au choix.  Déclarer et définir une
fonction qui calcule le pgcd de deux entiers positifs ou nuls. Ou
bien, déclarer et définir une procédure \verb|afficher_disque| qui
prend en paramètre un entier \C{rayon} et affiche un disque d'étoiles
de ce rayon.\bareme{2}


\begin{correction}
Voici trois corrigés, le pgcd récursif, un pgcd itératif (avec
boucles au lieu de récursion), la procédure
\C{afficher\_disque}.
Déclarations :
\begin{verbatim}
int pgcd_r(int a, int b);
int pgcd_i(int a, int b);
void afficher_disque(int rayon);
\end{verbatim}

Définitions :
\begin{verbatim}
int pgcd_r(int a, int b)
{
    if (a < b)
    {
	return pgcd(b, a);
    }
    if (b == 0)
    {
	return a;
    }
    return pgcd(b,  a % b);
}

int pgcd_i(int a, int b)
{
    int i;
    int min;
    int d;
    /* cas particuliers */
    if (a == 0)
    {
	return b;
    }
    if (b == 0)
    {
	return a;
    }
    /* min = minimum(a, b) */
    if (a < b)
    {
	min = a;
    }
    else
    {
	min = b;
    }
    /* diviseurs */
    for (i = 1; i <= min; i = i + 1)
    {
	/* i diviseur commun ? */
	if ( (0 == a % i) && (0 == b % i) )
	{
	    d = i;
	}
    } /* d plus grand diviseur commun */
    return d;
}

void afficher_disque(int rayon)
{
    /* on balaie le carré contenant le disque, de coté = 2 rayons + 1,
       et on affiche une étoile si la distance au centre est
       inférieure au rayon, sinon un blanc */
    int i;
    int j;
    for (i = -rayon; i <= rayon; i = i + 1)
    {
	for (j = -rayon; j <= rayon; j = j + 1)
	{
	    if ( (i*i+j*j) <= rayon*rayon )
	    {
		printf("*");
	    }
	    else
	    {
		printf(" ");
	    }
	}
	printf("\n");
    }	
}
\end{verbatim}
\end{correction}

%\newpage
%\hfill Total des points (bonus inclus) : \thetotalpointsint


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "final_bareme"
%%% End: 