\documentclass[xcolor=pdftex,svgnames,table]{beamer}
\input{communs/slides_style}

%%% Titre -- cours 8
\title{Éléments d'informatique -- Cours 7. Fonctions (1)}
\author{Pierre Boudes}
\date{\today}

\begin{document}

%% Page de titre et licence CC.
\begin{frame}
	\titlepage
	\vfill
	\begin{center}
		\CcGroupByNcSa{0.83}{0.95ex}\\[2.5ex]
		{\tiny\CcNote{\CcLongnameByNcSa}}
		\vspace*{-2.5ex}
	\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Cours en plusieurs parties sur les fonctions \nowrite}

\begin{enumerate}
    \item Principe de base, intérêt et analogie mathématique
    \item Fonctions sans entrée ou sans sortie, effets de bord
    \item Autres types que les entiers pour les paramètres et la sortie
    \item Pile d'appel, fonctions récursives
  \end{enumerate}
\end{frame}

\section[Plan]{}
\frame[label=plan]{\frametitle{Plan de la séance\nowrite}\tableofcontents}


\section[Introduction]{Définition et intérêt des fonctions en informatique}
\begin{frame}
  \frametitle{Définition et intérêt des fonctions en informatique}
  \begin{quote}
    En informatique, une fonction est une portion de code représentant
    un sous programme, qui effectue une tâche ou un calcul
    relativement indépendant du reste du programme. (wikipédia)
  \end{quote}
\pause
Intérêt des fonctions  :
  \begin{itemize}
  \item \structure{factorisation} : éviter la duplication de code en
    remplaçant les parties dupliquées par un appel à une fonction
    unique.\pause
    \item \structure{réutilisation} : une fonction peut être utilisée
      par plusieurs programmes (bibliothèque);\pause
    \item \structure{lisibilité} : regrouper un ensemble
      d'instructions dans une fonction, nommée de façon explicite,
      facilite la relecture du code et cache les détails de codage;\pause
    \item \structure{structuration} : découper en sous-problèmes;
      distribuer leur programmation à différente personnes, à
      différentes étapes de la réalisation d'un projet.\pause
  \end{itemize}
\end{frame}

\section{Analogie mathématique}
\begin{frame}
  \frametitle{Analogie mathématique \nowrite}
 \begin{itemize}
\item De même que le terme \emph{variable} peut avoir deux sens
    différents en informatique et en mathématiques, le terme
    \emph{fonction} recouvre des réalités différentes.\pause

\item Pour les fonctions, les deux notions sont historiquement très
    proches. C'est bien pour écrire des fonctions mathématiques que
    les fonctions informatiques ont été introduites.\pause

\item Mais qu'est-ce qu'une fonction mathématique ?
 \end{itemize}
\end{frame}

\subsection{La notion mathématique de fonction}
\begin{frame}
  \frametitle[En maths]{La notion mathématique de
    fonction}
 Une fonction mathématique est :\pause
  \begin{itemize}
  \item Une courbe ? \pause
  \item Une expression avec inconnues ($x^2 + 1$), une formule ?\pause
  \item Un terme dans une algèbre de fonctions ($f\circ g$, $f'$)
    ?\pause
  \item Une relation entre deux ensembles, entrées et sorties, telle
    que chaque entrée est en relation avec au plus une sortie
    (toujours la même). Le graphe de la fonction.\pause
  \end{itemize}
\pause
\begin{block}{À retenir} 
  En mathématiques, la manière dont la fonction est calculée ne fait
  pas partie de l'objet défini. Une fonction est une boîte noire.
\end{block}

\end{frame}

\section[En C]{Les fonctions en langage C}
\begin{frame}
\frametitle{Déclarer, appeler, définir.}
\pause
\begin{itemize}
\item \structure{Déclarer} : comme les variables, les fonctions
  doivent être déclarées avant usage pour fixer \alert{le nombre} et le type
  des arguments et de la sortie.\pause
\item \structure{Appeler} : utiliser une fonction, faire appel à son
  résultat en fixant les valeurs des arguments (paramètres effectifs).\pause
\item \structure{Définir} : décrire le corps de la fonction, c'est à
  dire la suite d'instructions qui constitue son calcul (sur des
  paramètres formels).
\end{itemize}
\end{frame}

\subsection{Appeler des fonctions}
\begin{frame}[fragile]
  \frametitle{Utiliser des fonctions : appeler}

Supposons que l'on dispose d'une fonction \C{maximum}, qui lorsqu'on
lui donne deux entiers nous renvoie le plus grand des deux. 
\pause
Nous pouvons l'utiliser de différentes façons :
\begin{lstlisting}[escapechar={\%},basicstyle=\ttfamily\small] 
int main ()
{
  int x = 3;
  int y = 4;
  int z;

  z = %\only<2->{\colorbox{yellow}{maximum}}%(x, y);%\pause%
  z = 2 + maximum(3 * 2, z);%\pause%
  x = maximum(maximum(3, y) + 1, z - 1);
\end{lstlisting}
\pause
Chaque entrée prend une valeur en fonction de l'expression passée en
argument. La fonction prend alors sa valeur de sortie.
%\pause
%\structure{Remarque :} \C{printf} et \C{scanf} sont des fonctions (un peu spéciales).
\end{frame}

\subsection{Créer des fonctions : déclarer, définir}
\begin{frame}[fragile]
  \frametitle{Créer des fonctions (1)  déclarer}
Déclarer une fonction c'est donner son prototype (ou signature), c'est
à dire son nom, le type de ses arguments, le type de sa sortie.\pause
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize] 
type_sortie nom_fonction(type1 param1, ..., typen paramn);
\end{lstlisting}
\pause
\begin{block}{Remarque} 
  Seule la déclaration des types est importante pour
  l'analyse sémantique. Cependant, le choix de noms de paramètres
  explicites fournit une documentation minimale.
\end{block}


\pause
\begin{block}{Exemple}
  
\begin{lstlisting}[basicstyle=\ttfamily\small] 
int puissance(int, int); 
int puissance(int base, int exposant);
\end{lstlisting}
\end{block}
\pause
\textbf{La déclaration doit se trouver avant tout appel.}
\end{frame}
\begin{frame}[fragile]
  \frametitle{Créer des fonctions (2)  définir}
\pause
Définir une fonction c'est donner l'ensemble des instructions qui
permettent, à partir des paramètres d'entrée, de calculer la valeur de
la fonction, dite valeur de retour, valeur renvoyée.\pause
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize] 
type_sortie nom_fonction(type1 param1, ..., typen paramn)
{
  /* declaration et initialisation variables */
 
  /* instructions */
}
\end{lstlisting}\pause
Les noms des paramètres
formels sont \C{param1}, \ldots, \C{paramn}, ils sont utilisés dans le
corps du calcul.
\pause 

Dès que la valeur de la 
fonction est calculée, on utilise l'instruction \C{return} qui marque
la fin du calcul et donne sa valeur à la fonction. \pause
\begin{lstlisting}[basicstyle=\ttfamily\small] 
  return expression_resultat;
\end{lstlisting}

La définition est obligatoire pour que l'édition de liens réussise et que l'exécutable soit créé. 
\end{frame}
\begin{frame}
    \frametitle{Variables locales, portée, durée}

    Le corps de la fonction peut déclarer des variables additionnelles,
    qui sont locales à la fonction (portée) et se voient allouer un
    espace mémoire pour chaque appel de la fonction (durée).

    \begin{block}{Remarque} \C{main} est une fonction (appelée au lancement du
      programme).
    \end{block}
\end{frame}


\begin{frame}
  \frametitle{Résumé}
 Utilisation des fonctions :
  \begin{itemize}
    \item \structure{déclaration} (types des paramètres et de la valeur de retour)
    \item \structure{définition}  (code, paramètres formels)
    \item \structure{appel} (paramètres effectifs, espace mémoire)
  \end{itemize}
\pause
\begin{block}{Convention de nommage} 
  Il est pratique de faire commencer le nom de chaque fonction par un
  verbe à l'infinitif \C{convertir\_\ldots}, \C{tester\_\ldots},
  etc. ou éventuellement par un verbe conjugué : par exemple \C{est\_}
  pour des fonctions à valeur de test (\C{est\_majeur},
  \C{est\_premier}, \ldots...)

Exceptions : la fonction est connue sous un autre nom
  (\C{factorielle}, \C{racine(x)}, \C{moyenne(...)}) 
\end{block}
\end{frame}

\subsection{Traces}
\begin{frame}
  \frametitle{Traces}

Pour tester nos programmes, nous faisons la trace de chaque appel de
chaque fonction que l'on a défini (les fonctions utilisateur, pas les fonctions externes, comme printf).

{
\rowcolors{2}{green!25}{yellow!50} %\arrayrulecolor{green!75!gray}
\small
      \setlength{\unitlength}{\tabcolsep}
          \begin{tabular}[t]{|c|c|l|}
          \multicolumn{3}{l}{\C{main()}}\\ \hline
          ligne & n & Affichage \\ \hline
          initialisation  & 9 & \\ \hline
          16 & & \pause  \\ \hline
\rowcolor{red!12}
          & & \multicolumn{1}{>{\columncolor{red!12}}r|}{
            \put(1,0){\noindent
              \begin{tabular}[t]{|c|c|c|l|}
          \multicolumn{4}{l}{\C{est\_premier(9)}}\\ \hline
          ligne & n & i & Affichage \\  \hline
          initialisation  & 9 & ? & \\ \hline
         34 &  & 2 & \\ \hline
         40  &  & 3 & \\ \hline
         38  &\multicolumn{3}{|>{\columncolor{green!25}}l|}{renvoie FALSE}\\ \hline 
        \end{tabular}
              }
          }\\ \hline  \pause
          22 & & 9 n'est pas premier\\ \hline
          26 &\multicolumn{2}{|>{\columncolor{yellow!50}}l|}{renvoie EXIT\_SUCCESS}\\ \hline
          \end{tabular}
}
\end{frame}




% \subsection[Utiliser des fonctions de bibliothèques]{Utiliser les
%   fonctions d'une bibliothèque}
% \begin{frame}[fragile]
%   \frametitle{Utiliser les fonctions d'une bibliothèque (math.h)}
% Utilisation de la bibliothèque math.h 
% \begin{verbatim}
% $ man math
% \end{verbatim}
%   \begin{block}{Déclarer}
%     \begin{lstlisting}[basicstyle=\ttfamily\small] 
% #include <math.h>
%      \end{lstlisting}
%   \end{block}

%   \begin{block}{Appeler}
%   \begin{lstlisting}[basicstyle=\ttfamily\small] 
%   double x;

%   x = log(3.5);
%     \end{lstlisting}  
%   \end{block}

%   \begin{block}{Définir}
% \begin{verbatim}
% $ gcc -lm -Wall prog.c -o prog.exe
% \end{verbatim}
%  \end{block}
% \end{frame}

%\subsection[Procédures]{Fonctions sans valeurs de retour (void)}
\begin{frame}[fragile]
  \frametitle{Fonctions sans valeurs de retour (void)}

On parle plutôt de procédure ou de routine car l'analogie avec les
fonctions mathématiques est perdu.

 \begin{block}{Déclarer}
    \begin{lstlisting}[basicstyle=\ttfamily\small] 
void afficher_valeurs(int x, int y);
     \end{lstlisting}
  \end{block}

  \begin{block}{Appeler}
  \begin{lstlisting}[basicstyle=\ttfamily\small] 
afficher_valeurs(5, 3);
   \end{lstlisting}  
  \end{block}

  \begin{block}{Définir}
Comme d'habitude mais pas de \C{return} (ou \C{return sans argument}).
\end{block}
\end{frame}

\subsection[Procédures]{Fonctions sans valeurs de retour (void)}
\begin{frame}[fragile]
  \frametitle{Fonctions sans arguments}

 \begin{block}{Déclarer}
    \begin{lstlisting}[basicstyle=\ttfamily\small] 
int nombre_aleatoire();
int saisie_utilisateur();
     \end{lstlisting}
  \end{block}

  \begin{block}{Appeler}
  \begin{lstlisting}[basicstyle=\ttfamily\small] 
  int n;
  int secret;

  secret = nombre_aleatoire();

  n = saisie_utilisateur();
   \end{lstlisting}  
  \end{block}

  \begin{block}{Définir}
Comme d'habitude.
\end{block}
\end{frame}


% \section[Démos]{Démos et fin}
% \begin{frame}
%   \frametitle{Démos et fin}
% \end{frame}
\end{document}

% revenir sur :
%-l'appel au cours suivant : paramètre et expression, pile d'appel.
%-la grammaire des identificateurs